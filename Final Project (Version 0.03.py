# -*- coding: utf-8 -*-
"""Final Project (Version 0.03).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17wBYA4aYCmWM9rywCqCZRvl6VSHf_766
"""

# Install fenics
def fenics():
    try:
        import dolfin
    except ImportError:
        # Install FEniCS if not installed
        !wget "https://fem-on-colab.github.io/releases/fenics-install-real.sh" -O "/tmp/fenics-install.sh"
        !bash "/tmp/fenics-install.sh"

    # Now try importing again
    import dolfin

# Execute function
fenics()

import math
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os

from matplotlib import pyplot as plt
from matplotlib import cm
from fenics import *

"""
Nicolino Primavera
FEM for Fluid Flow and FSI Interactions
Final Project
12/17/24
"""

print("\nStarting Program...\n")

"""
Problem II: Stokes Flow in a 2D Channel

Objective: compare the numerically predicted pressure gradient against anyalytical value assuming stokes flow

Stokes flow governing equations:
    ρ(∂u/dt - f^b) = ∇ ∙ σ
    ∇ ∙ u = 0 (incompressibility)
    -∇p + μ∇^2u = 0     (∇^2u represents the Laplacian of velocity)

Variables:
    σ_ij = -p*δ_ij + μ(u_i,j + u_j,i) - Cauchy stress for the fluid
    u - fluid velocity
    p - fluid pressure
    f^b - body force acting on the fluid
    ρ - fluid density
    μ - dynamic viscosity

Channel dimensions: 1cm (height) x 8cm (length)

Boundary Conditions:
    Inflow: Dirichlet condition with a velocity profile u/U_∞ = y/H * (1 - y/H) where U_∞ = 1 cm/s is the velocity at the centerline
    Outflow: Traction-free boundary condition
    Top/Bottom faces: Fixed walls (no slip / no penetration condition, u = 0)

Physical Parameters:
    Incompressible flow, no body force (f^b = 0)
    Fluid Density (ρ): 1.0 g/cm^3
    Fluid Viscosity (μ): 1.0 g/cm/s

The Reynolds number of the flow Re = (ρ)*(U_∞)*(H)/μ = 1, therefore, a Stokes flow is a reasonable assumption for the above configuration
"""

"""Problems:
- (a) Simulate the above problem using stabilized finite element (FE) method using a reasonably chosen grid and equal order discretization for fluid velocity and pressure. E.g., P1P1 (linear triangles for both velocity and pressure), Q1Q1 (bilinear 4-noded quadrilaterals for both velocity and pressure, etc.)

- (b) Simulate the above problem using inf-sup conforming finite elements. E.g., Q2Q1 discretization where the velocity functions are biquadratic (9-noded quadrilateral) and pressure is approximated using bilinear (4-noded quadrilateral) elements.
- (c) Plot profiles of velocity and streamlines at any axial cross-section.
- (d) Plot pressure along the centerline and compare the gradient against analytical expression assuming a fully developed parallel flow.
"""

# Initialize channel parameters
H = 1           # height of the channel (cm)
L = 8           # length of the channel (cm)
print(f"Channel dimensions: {L} cm x {H} cm\n")

# Fluid parameters
ρ = 1           # fluid density (g/cm^3)
μ = 1           # fluid viscosity (g/cm/s)
print(f"Fluid parameters: ρ = {ρ} g/cm^3, μ = {μ} g/cm/s")

# Create a rectangular mesh with a specified number of elements
nx, ny = 80, 10  # Elements along x and y directions
mesh = RectangleMesh(Point(0, 0), Point(L, H), nx, ny)

# General information about the mesh
print("Mesh Information:")
print(mesh)

# Print the number of cells (elements) and vertices (nodes)
print(f"\nNumber of cells (elements): {mesh.num_cells()}")
print(f"Number of vertices (nodes): {mesh.num_vertices()}\n")

# Print the geometric dimensions of the mesh
print(f"Mesh geometry dimension: {mesh.geometry().dim()}\n")
print(f"Mesh coordinates:\n {mesh.coordinates()}\n")
print(f"Mesh cell vertices:\n {mesh.cells()}\n")

# For a 2D mesh, retrieve the number of elements in each direction (nx, ny)
coords = mesh.coordinates()
x_coords = coords[:, 0]  # x-coordinates of all points
y_coords = coords[:, 1]  # y-coordinates of all points

# Number of unique points in each direction
unique_x = np.unique(x_coords)
unique_y = np.unique(y_coords)

print(f"Number of elements along x: {len(unique_x) - 1}")
print(f"Number of elements along y: {len(unique_y) - 1}\n")

# Plot
plt.plot(x_coords, y_coords, 'o')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Mesh Points')
plt.grid(True)
plt.show()

# P1P1 Simulation with Stabilization
print("Running simulation with P1P1 linear elements (equal-order)...\n")

# Define function spaces for velocity and pressure (P1P1)
V_P1 = VectorFunctionSpace(mesh, "P", 1)  # Velocity space (vector field, linear elements)
Q_P1 = FunctionSpace(mesh, "P", 1)       # Pressure space (scalar field, linear elements)

print(f"Velocity space (vector field, linear elements):\n   {V_P1}\n")
print(f"Pressure space (scalar field, linear elements):\n   {Q_P1}\n")

# Plots - error handling

# Velocity space (represents a vector field)
u_zero = Function(V_P1)    # Create a zero vector function in the velocity space
plot(u_zero, title="Velocity Space Basis Functions (P1)")   # Plotting a zero field gives an idea of the mesh layout
plt.xlabel("x")
plt.ylabel("y")
plt.show()

# Pressure space (represents a scalar field)
p_zero = Function(Q_P1)  # Create a zero scalar function in the pressure space
plot(p_zero, title="Pressure Space Basis Functions (P1)")
plt.xlabel("x")
plt.ylabel("y")
plt.show()

# Plot the underlying mesh structure used in these function spaces
plot(mesh, title="Mesh Structure")
plt.xlabel("x")
plt.ylabel("y")
plt.show()

# Label nodes and elements
coords = mesh.coordinates()
for i, (x, y) in enumerate(coords):
    plt.text(x, y, str(i), color="red")  # Label nodes with their indices
    plt.title("Mesh Structure with Node Labels")

plt.show()

# For part (a), simulate the stabilized finite element (FE) method using a reasonably chosen grid and equal order discretization (ex. P1P1 or Q1Q1)

# Define mixed element for velocity (vector field) and pressure (scalar field)
element_1 = MixedElement([V_P1.ufl_element(), Q_P1.ufl_element()])  # uses equal-order interpolation (P1-P1) - linear triangles for both velocity and pressure

# Create the mixed function space using the mixed element for P1P1
W_P1 = FunctionSpace(mesh, element_1)

print(f"Mixed element: \n {element_1}\n")
print(f"Mixed function space: \n  {W_P1}\n")

# Plot the initial fields

# Create a zero function in the mixed space
w_test_1 = Function(W_P1)

# Split into velocity and pressure components
u_mixed, p_mixed = w_test_1.split()

# Plot the velocity field (vector field)
velocity_plot = plot(u_mixed, title="Velocity Field", cmap='viridis')  # You can choose the colormap
plt.colorbar(velocity_plot)  # Attach the colorbar to the plot
plt.xlabel("x")
plt.ylabel("y")
plt.show()

# Plot the pressure field (scalar field)
pressure_plot = plot(p_mixed, title="Pressure Field", cmap='viridis')  # You can choose the colormap
plt.colorbar(pressure_plot)  # Attach the colorbar to the plot
plt.xlabel("x")
plt.ylabel("y")
plt.show()

# Split into trial and test functions
(u, p) = TrialFunctions(W_P1)
(v, q) = TestFunctions(W_P1)

#print(f"Trial functions (u, p): \n  {u}, {p}\n")
#print(f"Test functions (v, q): \n  {v}, {q}\n")

# Define the parabolic inflow velocity profile
U_in = Expression(("4.0 * U_max * x[1] * (H - x[1]) / pow(H, 2)", "0.0"), U_max=1.0, H=H, degree=2)  # U_max = centerline velocity
U_max = 1.0  # Maximum centerline velocity

#print(f"Inflow velocity profile: \n{U_in}\n")

# Create a mesh grid for the whole domain
x_vals = np.linspace(0, L, 100)
y_vals = np.linspace(0, H, 100)
X, Y = np.meshgrid(x_vals, y_vals)

# Compute the velocity components across the domain
U_x = np.zeros_like(X)  # Zero velocity in the x-direction
U_y = 4.0 * U_max * Y * (H - Y) / (H**2)  # Parabolic velocity profile in y-direction

# Plot the velocity field
plt.figure(figsize=(8, 6))
plt.quiver(X, Y, U_x, U_y, scale=5, color='blue')
plt.title("Inflow Velocity Profile (Vector Field)")
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)
plt.show()

# Bilinear form of Stokes equation
a = μ * inner(grad(u), grad(v)) * dx - div(v) * p * dx - div(u) * q * dx

# Linear form (no body forces) of Stokes equation
L = dot(Constant((0.0, 0.0)), v) * dx

# Bilinear form with stabilization
tau = Constant(0.1)  # Stabilization parameter (adjust based on mesh and flow properties)
a_P1 = (
    μ * inner(grad(u), grad(v)) * dx
    - div(v) * p * dx
    - div(u) * q * dx
    + tau * div(u) * div(v) * dx  # Stabilization term
)
L_P1 = dot(Constant((0.0, 0.0)), v) * dx

# Boundary conditions
bcs_P1 = [
    DirichletBC(W_P1.sub(0), U_in, "near(x[0], 0)"),  # Inflow
    DirichletBC(W_P1.sub(0), Constant((0.0, 0.0)),  # Walls
                "on_boundary && (near(x[1], 0) || near(x[1], {H}))".format(H=H))
]

# Solve the P1P1 system
w_P1 = Function(W_P1)
solve(a_P1 == L_P1, w_P1, bcs_P1)

# Check pressure solutions

p_values = p_P1.vector().get_local()
print("Min pressure:", np.min(p_values))
print("Max pressure:", np.max(p_values))
print("Any NaNs:", np.any(np.isnan(p_values)))
print("Any Infs:", np.any(np.isinf(p_values)))

# Extract and plot results for P1P1
(u_P1, p_P1) = w_P1.split()
plot(u_P1, title="Velocity Field (P1P1)")
plot(p_P1, title="Pressure Field (P1P1)")

# Compute and compare pressure gradient for P1P1
pressure_gradient_P1 = (
    p_P1(Point(x_coords[-1], H/2)) - p_P1(Point(x_coords[0], H/2))
) / L
print(f"Numerical Pressure Gradient (P1P1): {pressure_gradient_P1}")
relative_error_P1 = abs(
    (pressure_gradient_P1 - analytical_pressure_gradient)
    / analytical_pressure_gradient
) * 100
print(f"Relative Error (P1P1): {relative_error_P1:.2f}%\n")

# Initialize channel parameters
H = 1           # height of the channel (cm)
L = 8           # length of the channel (cm)
print(f"Channel dimensions: {L} cm x {H} cm")

# Fluid parameters
ρ = 1           # fluid density (g/cm^3)
μ = 1           # fluid viscosity (g/cm/s)
print(f"Fluid parameters: ρ = {ρ} g/cm^3, μ = {μ} g/cm/s\n")

# Create a rectangular mesh with a specified number of elements
nx, ny = 80, 10  # Elements along x and y directions
mesh = RectangleMesh(Point(0, 0), Point(L, H), nx, ny)

# Step 1: Define function spaces for P1P1 elements
V_P1 = VectorFunctionSpace(mesh, "P", 1)  # Velocity space (linear elements)
Q_P1 = FunctionSpace(mesh, "P", 1)       # Pressure space (linear elements)
W_P1 = FunctionSpace(mesh, MixedElement([V_P1.ufl_element(), Q_P1.ufl_element()]))

# Step 2: Trial and test functions
(u, p) = TrialFunctions(W_P1)
(v, q) = TestFunctions(W_P1)

# Step 3: Stabilization parameter
h = mesh.hmin()  # Minimum mesh size
tau = Constant(1 * h / μ)  # Stabilization parameter

# Step 4: Define bilinear and linear forms with stabilization
a_P1 = (
    μ * inner(grad(u), grad(v)) * dx
    - div(v) * p * dx
    - div(u) * q * dx
    + tau * div(u) * div(v) * dx  # Stabilization for continuity
    + tau * p * q * dx            # Pressure stabilization
)

L_P1 = dot(Constant((0.0, 0.0)), v) * dx

# Refine the mesh
nx, ny = 320, 80  # Further refined mesh
mesh = RectangleMesh(Point(0, 0), Point(L, H), nx, ny)

# Step 5: Apply boundary conditions
bcs_P1 = [
    DirichletBC(W_P1.sub(0), U_in, "near(x[0], 0)"),  # Inflow
    DirichletBC(W_P1.sub(0), Constant((0.0, 0.0)),   # No-slip walls
                "on_boundary && (near(x[1], 0) || near(x[1], {H}))".format(H=H)),
    DirichletBC(W_P1.sub(1), Constant(0.0), "near(x[0], 0)")  # Pressure reference
]

# Step 6: Solve the system
w_P1 = Function(W_P1)

# Enable verbose solver output for debugging
PETScOptions.set("ksp_type", "cg")  # Conjugate gradient method
PETScOptions.set("pc_type", "ilu")  # Incomplete LU preconditioning
PETScOptions.set("ksp_monitor")  # Enable solver monitoring

# Assemble and solve
solve(a_P1 == L_P1, w_P1, bcs_P1)

# Step 7: Extract velocity and pressure solutions
(u_P1, p_P1) = w_P1.split()

# Compute analytical pressure gradient
U_max = 1.0  # Maximum velocity at centerline (cm/s)
analytical_pressure_gradient = -2 * μ * U_max / (H**2)
print(f"Analytical Pressure Gradient: {analytical_pressure_gradient}")

# Compute the numerical pressure gradient
pressure_at_start = p_P1(Point(float(0), float(H / 2)))  # Start of the centerline
pressure_at_end = p_P1(Point(float(L), float(H / 2)))   # End of the centerline
print(f"\nPressure at start (x=0): {pressure_at_start}")
print(f"\nPressure at end (x=L): {pressure_at_end}")
print(f"\nChannel Length (L): {L}")

# Compute pressure gradient
pressure_gradient_P1 = (pressure_at_end - pressure_at_start) / L
print(f"\nNumerical Pressure Gradient (P1P1): {pressure_gradient_P1}")

# Compute relative error compared to the analytical gradient
relative_error_P1 = abs(
    (pressure_gradient_P1 - analytical_pressure_gradient) / analytical_pressure_gradient
) * 100
print(f"\nRelative Error (P1P1): {relative_error_P1:.2f}%")

# Step 8: Check pressure values
p_values = p_P1.vector().get_local()
print("\nMin pressure:", np.min(p_values))
print("Max pressure:", np.max(p_values))
print("Any NaNs:", np.any(np.isnan(p_values)))
print("Any Infs:", np.any(np.isinf(p_values)))

# Step 9: Plot results if values are valid
if not np.any(np.isnan(p_values)) and not np.any(np.isinf(p_values)):
    plot(u_P1, title="Velocity Field (P1P1)")
    plot(p_P1, title="Pressure Field (P1P1)")

    # Compute and compare pressure gradient
    pressure_gradient_P1 = (
        p_P1(Point(x_coords[-1], H/2)) - p_P1(Point(x_coords[0], H/2))
    ) / L
    print(f"\nNumerical Pressure Gradient (P1P1): {pressure_gradient_P1}")
    relative_error_P1 = abs(
        (pressure_gradient_P1 - analytical_pressure_gradient)
        / analytical_pressure_gradient
    ) * 100
    #print(f"\nRelative Error (P1P1): {relative_error_P1:.2f}%\n")
else:
    print("\nInvalid pressure values; check the solver or stabilization setup.")

